---
title: "정보처리기사 필기 2과목 최종 정리"
date: 2024-07-13 22:07:00 +09:00
categories: [Study, Engineer_Information_Processing]
tags: [정보처리기사, 필기정리, 2과목]
pin: true
---

정보처리기사 필기 제 2과목인 **소프트웨어 개발**부분을 정리하였습니다.    

<br>

### 자료 구조의 분류   

- 선형 구조(`Linear Structure`)  
  - 배열(Array)
  - 선형 리스트(Linear List)  
    - 연속 리스트, 연결 리스트
  - 스택(Stack)
  - 큐(Queue)
  - 데크(Deque) : 스택 + 큐

- 비선형 구조(`Non-Linear Structure`)
  - 트리(Tree)
  - 그래프(Graph)  

선형구조와 비선형 구조의 종류에 대해서 묻는 문제가 종종 출제되는데,  
비선형구조에는 '**트리, 그래프**'가 있다는 것을 알아두면 된다.   

----------------------------------------------------------------------  

### 스택 (Stack)   
- 한쪽 끝으로만 자료 삽입, 삭제 작업이 이루어짐  
- 후입선출(LIFO; Last In First Out)방식
- 모든 기억 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 `오버플로(Overflow)`가 발생
- 더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 `언더플로(Underflow)`가 발생

#### 스택 응용 분야  
인터럽트의 처리, 수식의 계산, 서브루틴의 복귀 번지 저장, 컴파일러를 이용한 언어 번역

### 큐 (Queue)  
- 시작과 끝을 표시하는 두 개의 포인터를 가짐
- 선입선출(FIFO; First In First Out)방식

<br> 

![스택과 큐](/assets/img/stack_queue.jpg){:style="width:70%; height:auto;"}    

----------------------------------------------------------------------  

### 그래프(Graph)  

정점 V(Vertex)와 간선 E(Edge)의 두 집합으로 이루어짐.  

- 간선의 방향성 유무에 따라..
  - 방향 그래프
  - 무방향 그래프

- 방향 그래프와 무방향 그래프의 최대 간선 수
  - 방향 그래프 최대 간선 수 : `n(n-1)`
  - 무방향 그래프 최대 간선 수 : `n(n-1)/2`  

<br> 

> 문제  

> Q. 정점이 5개인 방향 그래프가 가질 수 있는 최대 간선 수는? (단, 자기 간선과 중복 간선은 배제한다.)  

> 방향 그래프이므로, `n(n-1)` = 5 * 4 = 20  
> 따라서 최대 간선 수는 20이다.

----------------------------------------------------------------------

### 트리 운행법  

`Root`의 위치를 기억하면 쉽다.

- **Preorder** 운행 : `Root` → Left → Right
- **Inorder** 운행 : Left → `Root` → Right  
- **Postorder** 운행 : Left → Right → `Root`  

<br>

![트리 운행법](/assets/img/tree_order.jpg){:style="width:auto; height:auto;"}   
  
----------------------------------------------------------------------

### 수식의 표기법  

- 전위 표기법(PreFix) : +AB  
- 중위 표기법(InFix) : A+B  
- 후위 표기법(PostFix) : AB+  

<br>
  
Q. 전위식(prefix)을 후위식(postfix)으로 옳게 표현한 것은?  

**- / * A + B C D E**

(풀이)  
먼저, 피연산자 2개를 묶기  

(-(/(* A (+ B C))D)E)

그 다음 연산자를 피연산자 두개 뒤로 옮기기  

(((A(B C +)*)D/)E-)

마지막으로 괄호 벗기기  
결과: **A B C + * D / E -**

----------------------------------------------------------------------

### 정렬 (삽입, 선택, 버블)  

- 삽입 정렬  
  - n번째 키를 앞의 n-1개의 키와 비교해 알맞은 순서에 삽입하여 정렬하는 방식
  - 평균, 최악 모두 수행 시간 복잡도는 **O(n^2)** 이다.  

- 선택 정렬  
  - 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드에 놓는 방식을 반복하여 정렬하는 방식
  - 평균, 최악 모두 수행 시간 복잡도는 **O(n^2)** 이다.  

- 버블 정렬  
  - 인접한 두 개의 레코드 키 값을 비교해 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식
  - 평균, 최악 모두 수행 시간 복잡도는 **O(n^2)** 이다.

<br>

삽입, 선택, 버블 정렬을 사용해 숫자를 정렬하는 문제가 출제된다.  

삽입은 순서대로 본인 앞에 있는거를 비교하며 정렬하는 것이며,  
선택은 본인에서 순차적으로 한칸 한칸씩 옆으로 이동하며 모든 값 비교하며 정렬.  
(ex. 1회전 => 1번째 값으로 모든 값 확인하며 정렬, 2회전 => 2번째 값으로 모든 값 확인하며 정렬)  
버블은 1번 회전할때마다 모든 인접값들을 하나씩 비교하여 정렬하는것이다.  

----------------------------------------------------------------------  

### 소프트웨어 패키징  

모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것  

- 사용자 중심으로 진행
- 소스 코드는 향후 관리를 고려해 모듈화하여 패키징
- 사용자가 다양한 환경에서 소프트웨어를 쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징함  

<br>  

> Q. 소프트웨어 패키징에 대한 설명으로 틀린 것은?  

> **1번. 패키징은 개발자 중심으로 진행한다.**    
> 2번. 신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품으로 패키징한다.  
> 3번. 고객의 편의성을 위해 메뉴얼 및 버전관리를 지속적으로 한다.  
> 4번. 범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행된다.  

> 풀이: 패키징은 개발자 중심이 아니라 사용자 중심으로 진행한다.  

<br>

#### 패키징 고려사항  

- UI는 시각적인 자료와 함께 제공하고 메뉴얼과 일치시켜 패키징함
- 소프트웨어를 단순히 패키징해서 배포하는것이 끝이 아니라 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공하는 것이 좋음
- 내부 콘텐츠에 대한 암호화 및 보안을 고려
  - 사용자에게 배포되는 소프트웨어이기 때문
- 여러 단말기 간 DRM(디지털 저작권 관리) 연동 고려
- 사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려
- 제품 소프트웨어 종류에 적합한 암호화 알고리즘 적용  

<br>  

### 패키징의 형상관리  

형상관리(SCM; Software Configuration Management)  
: 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동  

- 소프트웨어 개발 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행
- 소프트웨어 개발의 전체 비용을 줄임
- 개발과정의 여러 방해 요인이 **최소화**되도록 보증
- 관리 항목엔 소스 코드뿐만 아니라 각종 정의서, 지침서, 분석서 등이 포함됨  

<br>  

> Q. 소프트웨어 형상 관리에 대한 설명으로 거리가 먼 것은?  

> 1번. 소프트웨어에 가해지는 변경을 제어하고 관리한다.  
> 2번. 프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 모두 관리 대상이다.  
> **3번. 대표적인 형상 관리 도구로 Ant, Maven, Gradle 등이 있다.**  
> 4번. 유지 보수 단계 뿐만 아니라 개발 단계에서도 적용할 수 있다.  

> 풀이: 빌드 자동화 도구에는 Ant, Maven, Gradle, Make, Jenkins 등이 있다.  
> 이중에 Jenkins와 Gradle이 가장 대표적이다.  

<br>

> Q. 소프트웨어 형상 관리에서 관리 항목에 포함되지 않는 것은?  

> 1번. 프로젝트 요구 분석서  
> 2번. 소스 코드  
> 3번. 운영 및 설치 지침서  
> **4번. 프로젝트 개발 비용**    

----------------------------------------------------------------------

### 애플리케이션 테스트  

확인(Validation) : 작업 제품이 **사용자**의 요구에 적합한지 측정  
검증(Verification) : 작업 제품이 **개발자**의 기대를 충족시키는지를 측정    


- 파레토 법칙 (Pareto Principle)
  - 애플리케이션의 20%에 해당하는 코드에서 전체 80%의 결함이 발견됨
- 살충제 패러독스 (Pesticide Paradox)  
  - 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않음
- 오류-부재의 궤변 (Absence of Errors Fallacy)  
  - 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없다


<br>

### 분류  

- 정적 테스트 : 프로그램 실행하지 않고 명세서, 소스코드를 분석  
  - 워크스루, 인스펙션, 코드 검사 등
- 동적 테스트 : 프로그램 실행 후 오류를 찾음, 모든 단계에서 테스트 수행 가능
  - 블랙박스 테스트, 화이트박스 테스트  

#### 화이트 박스 테스트  
모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 **논리**적인 모든 경로를 테스트해 테스트 케이스를 설계하는 방법  

- 기초 경로 검사(Base Path Testing) : 수행 가능한 모든 경로 
- 제어 구조 검사(Control Structure Testing)
  - 조건 검사(Condition Testing) : 논리적 조건을 테스트
  - 루프 검사(Loop Testing) : 반복(Loop)구조에 초점을 맞춰 실시
  - 데이터 흐름 검사(Data Flow Testing)

#### 블랙 박스 테스트    
각 기능이 완전히 작동되는 것을 입증하는 테스트 (=기능 테스트)  

- 동치(=동등) 분할 검사  
- 경계값 분석
- 원인-효과 그래프 검사
- 오류 예측 검사
- 비교 검사

----------------------------------------------------------------------

### 인수 테스트  
개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법이며,  
개발한 소프트웨어를 사용자가 직접 테스트한다.  

- 알파 테스트 : 사용자가 **개발자 앞**에서 테스트함
- 베타 테스트 : 선정된 최종 사용자가 **여러 명의 사용자 앞**에서 테스트함  

<br>  

Q. 알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?  
→ **인수 테스트**  

Q. 검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사는?  
→ **알파 검사**  

----------------------------------------------------------------------

### 상향식, 하향식 통합 테스트  

`상향식 통합 테스트`는 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법     

`하향식 통합 테스트`는 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법    

<br>  

Q. 통합 테스트(Integration Test)에 대한 설명으로 옳지 않은 것은?  

**1번. 하향식 통합 테스트는 드라이버를 이용하여 상위 모듈에서 하위 모듈 방향으로 테스트하는 기법이다.**  
2번. 상향식 통합 테스트는 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터가 필요하다.  
3번. 혼합식 통합 테스트는 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식이다.  
4번. 하향식 통합 테스트는 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트를 실시한다.  

→ **하향식** 통합 테스트는 **스텁(Stub)** 을 이용해 상위 모듈에서 하위 모듈 방향으로 테스트하는 기법   
→ **드라이버**를 이용하는것은 **상향식** 통합 테스트이다.  

----------------------------------------------------------------------

### EAI (Enterprise Application Integration)    
EAI는 비즈니스 간 통합 및 연계성을 높여 효율성 및 각 시스템 간의 확장성을 높여준다.  

- 구축 유형  
1. Point-to-Point : 애플리케이션을 1:1로 연결, 변경 및 재사용 어려움  
2. Hub & Spoke : 중앙 집중형 방식, 확장 및 유지 보수 용이
3. Message Bus (ESB 방식) : 애플리케이션 사이에 미들웨어를 두어 처리, 확장성이 좋고 대용량 처리 가능  
4. Hybrid : 데이터 병목 현상을 최소화 가능

<br> 

Q. EAI 구축 유형으로 옳지 않은 것?  
1번. Point-to-Point  
2번. Hub & Spoke  
3번. Message Bus  
**4번. Tree**  
